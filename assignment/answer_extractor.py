import copy
import string

import stanza

from assignment.question_classifier import *
from assignment.sentence_similarity_calculator import *

type_list = ["PERSON", "NORP", "ORG", "GPE", "LOC", ["FAC", "PRODUCT", "WORK_OF_ART", "LAW"], "EVENT", "LANGUAGE",
             "DATE", "PERCENT", "MONEY", "QUANTITY", "ORDINAL", ["CARDINAL", "TIME"]]

positive_words = ["yes", "certain", "sure", "indeed", "affirm", "agree", "positive", "correct", "right", "definite",
                  "surely", "certainly", "definitely"]
negative_words = ["no", "not", "never", "none", "neither", "nor", "without", "deny", "refuse", "reject", "incorrect",
                  "wrong"]
# 选取名词、代词、副词、形容词、动词作为keyword
key_pos = ["NOUN", "PROPN", "ADJ", "ADV", "VERB"]


def get_entities(doc):
    entities = []
    for sentence in doc.sentences:
        for entity in sentence.ents:
            # print(f"entity: {entity.text}, type: {entity.type}")
            entities.append(entity.text)
    return entities


def extract_keywords_by_pos(doc):
    keywords = set()
    for sent in doc.sentences:
        for word in sent.words:
            if word.upos in key_pos:
                keywords.add(word.lemma)
    return keywords


def extract_keywords(doc):
    # merge two sets as keywords set
    key_entities = set(get_entities(doc))
    key_words = extract_keywords_by_pos(doc)
    merged_set = copy.deepcopy(key_entities)

    for word in key_words:
        if not any(str.lower(word) in str.lower(entity).split(" ") for entity in key_entities):
            merged_set.add(word)

    return merged_set


def cal_distance_score(text, keywords, word):
    text = str.lower(text)
    keywords = [word.lower() for word in keywords]
    word = str.lower(word)
    # some random text should never be generated by LLM
    replace_candidate = ["@&*씨sバ9!$", "x遪q39발c3", "..3n3敵jnカ\\#*2_"]
    replacement = None
    for candidate in replace_candidate:
        if candidate not in text:
            replacement = candidate
            break

    translator = str.maketrans("", "", string.punctuation)
    text = text.translate(translator)  # remove punctuation
    text = text.replace(word, replacement).split(" ")

    keywords_idx = []
    word_idx = text.index(replacement)
    for keyword in keywords:
        idx = text.index(keyword) if keyword in text else -1
        keywords_idx.append(idx)

    distance = 0
    for idx in keywords_idx:
        if idx == -1:
            distance += 3
        else:
            distance += abs(word_idx - idx) / len(text) * 1.5
    score = 3 - distance / len(keywords)
    return score


def get_type_score(entity_type, question_type):
    if isinstance(question_type, list):
        return 3 if entity_type in question_type else 0
    return 3 if entity_type == question_type else 0


def get_ans_entity_candidates(ans_doc, q_ent_type, keywords):
    candidates = []
    keywords = {keyword.lower() for keyword in keywords}
    for sentence in ans_doc.sentences:
        for entity in sentence.ents:
            # print(f"entity: {entity.text}, type: {entity.type}")
            entity_text = str.lower(entity.text)
            # assume answer entity won't appear in the question.
            if entity_text not in keywords:
                type_score = get_type_score(entity.type, q_ent_type)
                distance_score = cal_distance_score(sentence.text, keywords, entity.text)
                # print(type_score, distance_score)
                candidates.append((entity.text, type_score + distance_score))

    return candidates


def extract_boolean_answer(question, ans_doc):
    pairs = [(question, answer_sentence.text) for answer_sentence in ans_doc.sentences]
    similarities = cal_sentence_similarity(pairs)
    ans_score = 0

    for i, sentence in enumerate(ans_doc.sentences):
        # check sentences highly related with question or short enough
        if similarities[i] >= 0.75 or len(sentence.words) <= 6:
            # print("match sentence:", sentence.text, sentence.sentiment)
            sentence_score = sentence.sentiment - 1  # 0,1,2 negative, neutral, positive

            if sentence_score == 0:
                for word in sentence.words:
                    word_score = 0
                    if word.lemma in positive_words:
                        word_score = 1
                    elif word.lemma in negative_words:
                        word_score = -1

                    if sentence_score == 0 and word_score != 0:
                        sentence_score += word_score
                    elif word_score != 0:
                        sentence_score *= word_score
            ans_score += sentence_score * similarities[i]
    # if sentence_score > 0:  # positive
    # 	ans_score += similarities[i]
    # elif sentence_score < 0:  # negative
    # 	ans_score -= similarities[i]
    # print(ans_score)
    final_ans = "not given"
    if ans_score > 0:
        final_ans = "yes"
    elif ans_score < 0:
        final_ans = "no"

    return final_ans


def get_ent_type(question):
    ent_type = classify_entity_question(question)
    return type_list[ent_type]


def extract_entity_answer(ques_doc, ans_doc, ent_type):
    # use word type, similarity to question, distance to keywords

    # get keywords from question
    keywords = extract_keywords(ques_doc)
    # print("keywords:", keywords)
    # select candidate entities with type score and distance score.
    candidates = get_ans_entity_candidates(ans_doc, ent_type, keywords)
    if not candidates:
        return None

    pairs = [(ques_doc.text, candidate[0]) for candidate in candidates]
    similarities = cal_sentence_similarity(pairs)
    # add similarity
    candidates = [(tup[0], tup[1] + val) for tup, val in zip(candidates, similarities)]
    # print(candidate)

    entity = max(candidates, key=lambda x: x[1])
    return entity[0]


def extract_answer(ques_doc, ans_doc):
    question = ques_doc.text
    question_type = classify_question(question)
    if question_type == 0:
        # open question. select from entity candidates
        print("type: entity question")
        return extract_entity_answer(ques_doc, ans_doc, get_ent_type(question))
    else:
        # boolean question. use keyword
        print("type: boolean question")
        return extract_boolean_answer(question, ans_doc)


if __name__ == "__main__":
    # test
    stanza.download('en')  # download English model
    # initialize English neural pipeline
    nlp = stanza.Pipeline(lang='en', processors='tokenize,ner,mwt,pos,lemma,sentiment', download_method=None)


    def test(ques, ans):
        print("question:", ques)
        print("answer:", ans)
        a_doc = nlp(ans)
        q_doc = nlp(ques)
        print(f"extracted: {extract_answer(q_doc, a_doc)}\n")


    q = "Is Rome the capital of Italy?"
    a = (
        "surely it is but many don’t know this fact that Italy was not always called as Italy. Before Italy came "
        "into being in 1861, it had several names including Italian Kingdom, Roman Empire and the Republic of "
        "Italy among others. If we start the chronicle back in time, then Rome was the first name to which Romans "
        "were giving credit. Later this city became known as “Caput Mundi” or the capital of the world...")
    test(q, a)

    q = "Managua is not the capital of Nicaragua. Yes or no?"
    a = ("Most people think Managua is the capital of Nicaragua. However, Managua is not the capital of Nicaragua. The "
         "capital of Nicaragua is Managua. The capital of Nicaragua is Managua. Managua is the capital of Nicaragua. "
         "The capital")
    test(q, a)

    q = "sky isn't blue, right?"
    a = ("The statement \"the sky isn't blue\" is not accurate. The Earth's atmosphere, particularly the gases and "
         "particles in the air, scatters sunlight, making the sky appear blue. This phenomenon is known as Rayleigh "
         "scattering, named after Lord Rayleigh, who first described it in the late 19th century. The blue color we "
         "see in the sky is a result of the scattering of sunlight by the tiny molecules of gases in the atmosphere, "
         "such as nitrogen and oxygen. The shorter, blue wavelengths are scattered in all directions, while the "
         "longer, red wavelengths pass straight through the atmosphere with little scattering, which is why the sky "
         "typically appears blue during the daytime. It's worth noting that the color of the sky can change depending "
         "on the time of day and atmospheric conditions. For example, during sunrise and sunset, the sky can take on "
         "hues of red, orange, and pink, due to the scattering of light by atmospheric particles. However, "
         "the blue color of the sky remains a constant feature of the Earth's atmosphere under normal conditions.")
    test(q, a)

    q = "the capital of nicaragua is..."
    a = ("Prior to 1979, Nicaragua was known as the Republic of Nicaragua. It is a republic with a presidential system "
         "of government. The capital of Nicaragua is Managua. The capital of Nicaragua is Managua. What is the capital "
         "of nicar")
    test(q, a)

    q = "who was the first president of the Netherlands?"
    a = ("The first president of the Netherlands was Queen Wilhelmina, who served from 1890 to 1943. She was the first "
         "monarch to be appointed as president of the Netherlands, and she played a significant role in the country's "
         "history, particularly during World War II.")
    test(q, a)
